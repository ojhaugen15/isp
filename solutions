` Reverse A Singly-Linked List 
`... requires that atomic 'o' creates "list" when only one argument

:reverseString inputString
:a previousNode :u inputString;
:a currentNode :y :u inputString;;
:a outputString :o :u previousNode;;
:i :areSame currentNode null;
::a nextNode :y currentNode;
::y :u currentNode; previousNode outputString
::a previousNode currentNode
::a currentNode nextNode
:e outputString


` Flatten An Array
`... no solution, as 'isp' does not include 'lists of lists' but here is what I would do with "bracket-script" (my subset of 'JavaScript')... 

function flattenArray (inputArray, currentIndex, currentOutput) {
 outputArray = []
 searchIndex = 0
 if (arentSame(currentIndex, undefined)) {
  searchIndex = currentIndex
  outputArray = currentOutput
 }
 arraySize = getValue(inputArray, 'length')
 while (firstGreater(arraySize, searchIndex)) {
  currentItem = getValue(inputArray, searchIndex)
  if (isArray(currentItem)) {
   index2 = 0
   size2 = getValue(currentItem, 'length')
   while (firstGreater(size2, index2)) {
    item2 = getValue(currentItem, index2)
    outputArray.push(item2)
    index2 = addNumbers(index2, 1)
   }
   currentIndex = addNumbers(searchIndex, 1)
   outputArray = flattenArray(inputArray, currentIndex, currentOutput)
   return outputArray
  }
  outputArray.push(currentItem)
  searchIndex = addNumbers(searchIndex, 1)
 }
 return outputArray
}


` Max Product Finder
`...... requires that atomic 'o' does nothing when second argument "null" 

:orderNumbers numberList
:a currentNode :u numberList;
:a greatestNumber :u :u numberList;;
:a greaterFound false
:a cloneList :o :u numberList;;
:i :arentSame currentNode null;
::a currentNumber :u currentNode;
::i :firstGreater currentNumber greatestNumber;
:::a greaterFound true
:::o cloneList greatestNumber
:::a greatestNumber currentNumber
:::a currentNumber null
::o cloneList currentNumber
::a currentNode :y currentNode;
:i :areSame greaterFound false;
::y cloneList :y :u cloneList;;
::a greaterFound true
:a lesserOrdered :orderNumbers cloneList;
:e :o greatestNumber lesserOrdered;


` Semi-Prime Numbers

a prime_list :o 2 3;

:countSemiprime inputNumber currentIndex currentCount
:a searchIndex 5
:a countOutput 3
:a searchEnd :roundDown :quotientNumbers inputNumber 2;;
:i :arentSame currentIndex undefined;
::a searchIndex currentIndex
::a countOutput currentCount
::a currentIndex undefined
:i :firstGreater searchEnd searchIndex;
::i :isPrime searchIndex;
:::a currentNode :u prime_list;
:::i :andValues :arentSame currentNode null; :firstGreater inputNumber :multiplyNumbers :u currentNode; searchIndex;;;
::::a countOutput :addNumbers countOutput 1;
::::a currentNode :y currentNode;
:::e :countSemiprime inputNumber :addNumbers searchIndex 2; countOutput;
::a searchIndex :addNumbers searchIndex 2; 
:e countOutput

:isPrime inputNumber
:a currentNode :u prime_list;
:i :arentSame currentNode null;
::i :areSame false :noRemainder inputNumber :u currentNode;;;
:::e false
::a currentNode :y currentNode;
:o prime_list inputNumber
:e true

:noRemainder number1 number2
:i :areSame 0 :getRemainder number1 number2;;
::e true
:e false


` Reverse Words

:reverseWords inputString
:a currentNode :u inputString;
:a outputString ''
:i :arentSame currentNode null;
::a currentCharacter :u currentNode;
::i :areSame currentCharacter ' ';
:::a outputString :o ' ' outputString;
:::e :reversalEngine outputString :y currentNode;;
::a outputString :o outputString currentCharacter;
::a currentNode :y currentNode;
:e outputString

:reversalEngine outputString currentNode
:a currentWord :u currentNode;
:i :arentSame currentNode null;
::a currentCharacter :u currentNode;
::i :areSame currentCharacter ' ';
:::a outputString :o ' ' outputString;
:::a outputString :o currentWord outputString;
:::e :reversalEngine outputString :y currentNode;;
::a currentWord :o currentWord currentCharacter;
::a currentNode :y currentNode;
:e outputString


` Product of Everything Else

:elseProduct numberString
:a stringSize :getSize numberString;
:a searchIndex 0
:i :firstGreater stringSize searchIndex;
::a outputString :o outputString 1;
::a searchIndex :addNumbers searchIndex 1;
:i :firstGreater stringSize searchIndex;
::a index2 0
::a currentNode :u numberString;
::a outputCurrent :u outputString;
::a saveIndex searchIndex
::i :firstGreater stringSize index2;
:::i :arentSame searchIndex index2;
::::u outputCurrent :multiplyNumbers :u outputCurrent; :u currentNode;;
::::a searchIndex null
:::a searchIndex saveIndex
:::a currentNode :y currentNode;
:::a outputCurrent :y outputCurrent;
:::a index2 :addNumbers index2 1;
::a searchIndex :addNumbers searchIndex 1;
:e outputCurrent
